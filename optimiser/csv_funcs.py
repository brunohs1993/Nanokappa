import os, re, subprocess, sys
from datetime import timedelta
from multiprocessing import Pool
import pandas as pd
from time import sleep

def get_exec_params(file):
    with open(file, 'r') as f:
        a = f.readlines()               # read options file

    a = [i.splitlines()  for i in a] # remove break line characters
    a = [i[0].split(' ') for i in a]   # split keys and values

    for i in a:
        while '' in i:
            i.remove('')

    options = {}
    for i in range(len(a)):
        try:
            options[a[i][0]] = int(a[i][1])
        except:
            options[a[i][0]] = a[i][1]
    
    return options

def import_params(file):
    params = pd.read_csv(file)                       # read simulation parameters from csv data
    params.replace(float('nan'), '', inplace = True) # replace nan values with empty strings

    return params

def generate_results_folder(folder):
    '''Generate the result folder in place, with the
       name given as argument.'''

    folders = os.listdir() # get folders in working directory

    valid_folders = [i for i in folders if i.startswith(folder+'_')] # get folders that start with the same name

    if len(valid_folders) == 0: # if there is no folder with desired name, create the first (zeroth) one
        folder = folder+'_0'
    else:                       # if there is, create the next one
        numbers = [int(i[ len(folder)+1: ]) for i in valid_folders ]
        
        folder = folder + '_{:d}'.format(max(numbers)+1)

    os.mkdir(folder)    # create folder
    
    return folder

def time_for_cluster(t, margin = '0-00:10:00', return_timedelta = False):
    '''Add an extra margin to maximum simulation time to
       avoid the cluster finishing the job before the simulation ends.
       The standard is '''

    t = re.split('-|:', t)
    m = re.split('-|:', margin)
    
    t = [int(i) for i in t]
    m = [int(i) for i in m]

    c = [t[i]+m[i] for i in range(4)]

    if c[3] >= 60:
        c[2] += c[3] // 60 # extra minutes
        c[3]  = c[3] %  60
    if c[2] >= 60:
        c[1] += c[2] // 60 # extra minutes
        c[2]  = c[2] %  60
    if c[1] >= 24:
        c[0] += c[1] // 24 # extra minutes
        c[1]  = c[1] %  24
    
    if return_timedelta:
        return timedelta(days   = c[0],
                         hours   = c[1],
                         minutes = c[2],
                         seconds = c[3])
    
    else:
        return '{:d}-{:s}:{:s}:{:s}'.format(c[0],
                                            str(c[1]).zfill(2),
                                            str(c[2]).zfill(2),
                                            str(c[3]).zfill(2))

def exec_sim(sim_params, mode, exec_params):
    if mode == 'cluster':

        folder = generate_results_folder(sim_params['results_folder'])  # creates results folder
        os.chdir(folder)                                               # go to folder

        exec_params['time']           = time_for_cluster(sim_params['max_sim_time']) # add margin for cluster time
        exec_params['material_folder']  = sim_params['mat_folder'].split(' ') # the material path is a list of material folders
        
        material_files = [sim_params['hdf_file'].split(' '), sim_params['poscar_file'].split(' ')] # and get hdf and poscar
        for m in material_files:
            m = m.remove('')

        if len(exec_params['material_folder']) > 1:                   # if there is more than one material informed, we can safely
            exec_params['material_folder'].remove('')                 # remove extra strings generated by eventual double spaces
        
        

        exec_params['material_files'] = [[material_files[0][i], material_files[1][i]] for i in range(len(exec_params['material_folder']))]

        if sim_params['geometry'] in ['cuboid', 'cylinder', 'cone', 'capsule']:
            exec_params['geometry_file'] = None
        else:
            exec_params['geometry_file'] = sim_params['geometry']

        # generates slurm script
        generate_script(job_name         = exec_params['job_name'],
                        nanokappa_folder = exec_params['nanokappa_folder'],
                        material_folder  = exec_params['material_folder'],
                        material_files   = exec_params['material_files'],
                        geometry_file    = exec_params['geometry_file'],
                        conda_env        = exec_params['conda_env'],
                        time             = exec_params['time'],
                        partition        = exec_params['partition'],
                        n_of_nodes       = exec_params['n_of_nodes'],
                        n_of_tasks       = exec_params['n_of_tasks'],
                        mail_type        = exec_params['mail_type'],
                        mail_user        = exec_params['mail_user'])
        
        # override sim parameters for cluster execution
        sim_params['results_location'] = 'local'
        sim_params['results_folder']   = 'results'
        sim_params['mat_folder']  = ['mat_{:d}'.format(i) for i in range(len(exec_params['material_folder']))]
        if sim_params['geometry'] is not None:
            sim_params['geometry'] = os.path.basename(sim_params['geometry'])

        generate_parameter_file(sim_params) # generate parameters file

        print(os.listdir())

        subprocess.run('sbatch script', shell = True) # run script

        os.chdir('..') # go back to main result folder

    elif mode == 'local':

        wait_time = time_for_cluster(sim_params['max_sim_time'], return_timedelta = True, margin = '0-00:01:00')
        
        cmd = 'conda run -n nanokappa python {}/nanokappa.py'.format(exec_params['nanokappa_folder'])
        for k in sim_params.keys():
            cmd += ' --{} {}'.format(k, sim_params[k])

        if sys.platform in ['linux', 'linux2']:
            sp = subprocess.Popen('gnome-terminal --wait -- ' + cmd, shell = True)
            sp.wait()
        elif sys.platform == 'darwin':
            sp = subprocess.Popen("osascript -e 'tell app \"Terminal\" to do script \"{}\"' ".format(cmd), shell = True)
            sp.wait()
        elif sys.platform == 'win32':
            sp = subprocess.Popen('wt '+cmd, shell = True)
            sleep(wait_time.total_seconds())

    else:
        raise Exception('Wrong mode. Please choose from "cluster" or "local".')

def generate_script(job_name,
                    nanokappa_folder,
                    material_folder,
                    material_files,
                    geometry_file,
                    conda_env,
                    time = '1-00:00:00',
                    partition = 'std',
                    n_of_nodes = 1,
                    n_of_tasks = 1,
                    mail_type = 'ALL',
                    mail_user = None):

    '''THIS HAS BEEN TESTED ON UNIVERSITÃ‰ DE LORRAINE'S CLUSTER EXPLOR ONLY.'''

    s = '#!/bin/bash\n' + \
        '#SBATCH -C NOPREEMPT' + \
        '#SBATCH -p {:s}\n'.format(partition) + \
        '#SBATCH -N {:d}\n'.format(n_of_nodes) + \
        '#SBATCH -J {:s}\n'.format(job_name) + \
        '#SBATCH -n {:d}\n'.format(n_of_tasks) + \
        '#SBATCH -t {:s}\n'.format(time)
    
    if mail_user is not None:
        s+= '#SBATCH --mail-type={:s}\n'.format(mail_type) + \
            '#SBATCH --mail-user={:s}\n'.format(mail_user)
    
    # initialise conda, create workdir and copy nanokappa
    s+= 'module purge\n' + \
        'module use -a /opt/modulefiles/shared/mcs_mod/\n' + \
        'module load mcs_mod/softwares/anaconda3/2022.05\n' + \
        'source $HOME_ANACONDA/anaconda.rc\n' + \
        'WORKDIR=$SCRATCHDIR/job.$SLURM_JOB_ID.$USER\n' + \
        'mkdir -p $WORKDIR\n' + \
        'cp -rf {:s} $WORKDIR\n'.format(nanokappa_folder)

    # copy materials files
    for mi in range(len(material_folder)):
        s+= 'mkdir -p $WORKDIR/mat_{:d}\n'.format(mi) + \
            'cp -rf {:s} $WORKDIR/mat_{:d}/\n'.format(material_folder[mi] +'/'+ material_files[mi][0], mi) + \
            'cp -rf {:s} $WORKDIR/mat_{:d}/\n'.format(material_folder[mi] +'/'+material_files[mi][1], mi)

    # copy geometry file if needed
    if geometry_file is not None:
        s+= 'cp -rf {:s} $WORKDIR\n'.format(geometry_file)
    
    # copy parameters and run simulation
    s+= 'cp -rf parameters.txt $WORKDIR\n' + \
        'cd $WORKDIR\n' + \
        'conda activate {:s}\n'.format(conda_env) + \
        'srun python {:s}/nanokappa.py -ff parameters.txt\n'.format(os.path.basename(nanokappa_folder)) + \
        'cp -rf results*/* $SLURM_SUBMIT_DIR/.'

    # save script    
    with open('script', 'w') as f:
        f.write(s)
        f.close()

def generate_parameter_file(sim_params):
    '''sim_params is a dict with the complete simulation parameter names as keys and
     its value(s). Accetps string, int, float, list or tuple as value types.
     
     Example:
     {'particles':1e7,
      'bound_pos':['relative', 0, 0.5, 0.5, 1, 0.5, 0.5],
      'bound_cond':'T T R',
      ...}
      
      '''
    
    s = ''
    for k in sim_params.keys():
        if type(sim_params[k]) in [list, tuple]:
            values = ''
            for v in sim_params[k]:
                values = values+'{} '.format(v)
        else:
            values = '{}'.format(sim_params[k])
        s += '--{:s} {:s}\n'.format(k, values)
    
    with open('parameters.txt', 'w') as f:
        f.write(s)
        f.close()